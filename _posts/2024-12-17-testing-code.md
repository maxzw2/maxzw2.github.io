---
layout: post
title: Testing My Code
---
How I've been checking my code, some findings on my habits, and other growths

I deviated from the original path that I was taught for Programming Fundamentals in testing my code. I'll be honest -- I was a little skeptical of assert statements. I decided to use my final project as an experiment in trying problems without them. I still spent plenty of time analyzing the problem, input data, and my code through line tracing and following my input as it was modified and weeded through. I found that method beneficial, but I soon realized that my ignorance towards assert statements would return to get me.

I was wrong. Harshly. But, through this, I learned about the true goals behind making assert statements that weren't as clear to me before -- grasping your knowledge thoroughly. During coursework, I made assert statements and did rigorous testing behind my functions, but I didn't see that comprehension aspect. I felt uncomfortable making my assert statements; I brushed my negligence off as just laziness, but, through solving these problems and struggling, I realized what I was escaping from. It was tiring to think critically about the intended output and what would slip through the cracks, and a bit of a perfectionist mindset had me scared of potentially missing the one critical assert statement that makes or breaks my code.

This subconscious anxiety behind assert statements pushed me to just ignore them. I thought that since Advent of Code lets you know whether or not your answer is correct, then that would be all the information I needed. I now know that knowing whether or not you're correct isn't as important as why you're correct. 

I still paid a lot of attention to what edge cases I would get tripped up on and what my input looked like. I didn't feel confident in assert statements because I didn't know exactly what I was testing for in the first place. It felt quite different than my coursework for Programming Fundamentals. Instead of clear-cut definitions and other clarifications discussed in class, Advent of Code left me a little in the dust in knowing what should be covered or not. For example, one of the reasons why I was stuck on Day 2 Part 2 was because the example cases and definitions were not clear to me. After all, they were quite brief and I had no way of confirming if the cases I made were correct or not, unlike in class. I didn't fully realize what sorts of outliers could exist -- they weren't included in the definition. I thought that outliers could only be values that yield invalid differences, not any value that would deviate from the pattern -- that was one of my critical mistakes in analyzing using differences rather than the integer value. I often felt like I was going the wrong path or direction when writing my outlines and code -- I felt lost.

I tested my code by carefully following my input as it got modified, as that felt the most logical to me. Way more intuitive than assert statements that only tell me whether I'm right or wrong! (which is not their larger, intended purpose, as I would find out.) But, the reason why I stuck with this mode of testing was because it worked for me. I found multiple mistakes in my code, especially for Day 3, when I didn't pay close attention to the syntax the methods and functions were outputting. I had a positive feedback loop. I found errors when I tested my code by going through line by line and checking what I was getting based on my input data. I put in a lot of effort in analyzing the small details in my input data.

However, if I had considered my assert statements instead of picking this path of line tracing and using the Advent of Code built-in checker, I would have found the logical blunders much faster than my line-by-line debugging method. This way of testing is still valuable to me, but I realized how assert statements make you think harder about your code before you start writing it. That's where the value shows itself, despite being hidden from my ignorant habits. 

I realized getting your information on intended outputs down first opens the door to the assumptions that you should and shouldn't make in your code. What's best would be a combination of my input testing method and assert statements. In a situation where the input data is much larger and unmanageable for me, I'll need to rely on assert statements to clarify my logic and understanding. More testing!

When I get the chance to continue working on Advent of Code problems, assert statements will be, once again, the second thing I do after writing my documentation, just like in class. 
